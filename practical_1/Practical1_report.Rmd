---
title: "Practical 1 — River discharge & precipitation extremes (Neuchâtel)"
author: ""
date: "`r Sys.Date()`"
output:
  pdf_document:
    latex_engine: pdflatex
    toc: true
    number_sections: false
  word_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, fig.width = 7, fig.height = 4)
# Ensure working directory is project root when rendering
# If you render from a different folder, adjust paths accordingly
library(knitr)
```

# Introduction

This report reproduces the worked solution for Practical 1. It loads the daily river discharge and precipitation data for Neuchâtel, performs exploratory data analysis, fits extreme-value models (block maxima GEV for discharge and POT/GPD for precipitation), conducts a simple declustering procedure, inspects tail dependence, and runs the provided extreme causality tests from `JuroExtremes.R`.

All code here is executed; figures are embedded below and results saved to `practical_1/practical1_results.rds`.

# 0. Load packages and data
## Methodology
This section installs/loads the R packages required for the analysis and reads the CSV data. The data is expected to be in `practical_1/River_and_precip_Neuchatel.csv`.

## Results / Notes
Packages will be installed if missing; the small preview table below shows the first rows of the data.

```{r packages}
required_pkgs <- c('readr','lubridate','ggplot2','dplyr','evd','ismev','forecast','knitr')
missing <- required_pkgs[!required_pkgs %in% installed.packages()[,1]]
if(length(missing)) install.packages(missing, repos = 'https://cloud.r-project.org')

library(readr); library(lubridate); library(ggplot2); library(dplyr)
library(evd); library(ismev); library(forecast)

fig_dir <- file.path('practical_1','figures')
if(!dir.exists(fig_dir)) dir.create(fig_dir, recursive = TRUE)

data_path <- file.path('practical_1','River_and_precip_Neuchatel.csv')
stopifnot(file.exists(data_path))
raw <- read_csv(data_path, col_types = cols(Date = col_date(format = "%Y-%m-%d"),
                                             RiverDischarge = col_double(),
                                             Precipitation = col_double()))

df <- raw %>% rename(date = Date, discharge = RiverDischarge, precip = Precipitation)

# basic table
kable(head(df, 6))
```

# 1 Exploratory plots (time series + seasonality)

```{r eda-plots, fig.width=10, fig.height=3}
# ggplot time series
p1 <- ggplot(df, aes(x = date, y = discharge)) + geom_line(color='blue') + labs(title='River discharge — time series')
print(p1)

p2 <- ggplot(df, aes(x = date, y = precip)) + geom_line(color='darkgreen') + labs(title='Precipitation — time series')
print(p2)
```

### Methodology
We produce line plots of the daily series for visual inspection of trends and large events.

### Results / Comments
The plots below highlight periods of elevated discharge and precipitation; seasonal structure is also inspected with monthly boxplots below.

```{r ts-autoplot-acf, fig.width=10, fig.height=3}
# ts objects
ts_start_year <- year(min(df$date, na.rm = TRUE))
ts_discharge <- ts(df$discharge, start = c(ts_start_year,1), frequency = 365)
ts_precip <- ts(df$precip, start = c(ts_start_year,1), frequency = 365)
print(autoplot(ts_discharge) + labs(title='River discharge (ts object)'))
print(autoplot(ts_precip) + labs(title='Precipitation (ts object)'))

# ACFs
print(ggAcf(ts_discharge, lag.max = 50) + ggtitle('ACF - discharge (ts)'))
print(ggAcf(ts_precip, lag.max = 50) + ggtitle('ACF - precip (ts)'))
```

```{r monthly-boxplots, fig.width=8, fig.height=4}
df <- df %>% mutate(month = month(date, label = TRUE))
print(ggplot(df, aes(x=month, y=discharge)) + geom_boxplot() + labs(title='Monthly distribution of discharge'))
print(ggplot(df, aes(x=month, y=precip)) + geom_boxplot() + labs(title='Monthly distribution of precipitation'))
```


# 2 Summary statistics

### Methodology
Compute simple descriptive statistics: mean, standard deviation and counts of missing values.

### Results / Comments
The summary table provides an immediate check on data completeness and scale of the two series.

```{r summary-stats}
summary_stats <- df %>% summarize(
  n = n(),
  discharge_mean = mean(discharge, na.rm=TRUE),
  discharge_sd = sd(discharge, na.rm=TRUE),
  precip_mean = mean(precip, na.rm=TRUE),
  precip_sd = sd(precip, na.rm=TRUE),
  missing_discharge = sum(is.na(discharge)),
  missing_precip = sum(is.na(precip))
)

# present a compact, human-friendly table
summary_stats_fmt <- summary_stats %>%
  mutate(across(where(is.numeric), ~round(., 2)))
knitr::kable(summary_stats_fmt, caption = 'Summary statistics (rounded)')
```


# 3 Annual maxima and GEV for discharge

### Methodology
Compute annual block maxima of daily discharge and fit a GEV via maximum likelihood. We then compute an approximate 100-year return level from the fitted parameters.

### Results / Comments
The GEV parameter estimates and the 100-year return level are printed below. A histogram of annual maxima with the fitted GEV density is shown for visual fit assessment.

```{r gev-fit, fig.width=7, fig.height=4}
# annual maxima
library(stats)
df <- df %>% mutate(year = year(date))
annual_max <- df %>% group_by(year) %>% summarize(max_discharge = max(discharge, na.rm = TRUE)) %>% ungroup()

gev_fit <- fgev(annual_max$max_discharge)
print(gev_fit)
loc <- gev_fit$estimate['loc']; scale <- gev_fit$estimate['scale']; shape <- gev_fit$estimate['shape']
rl_100 <- qgev(1 - 1/100, loc = loc, scale = scale, shape = shape)
cat('Estimated 100-year return level (discharge):', rl_100, '\n')

xv <- seq(min(annual_max$max_discharge)*0.9, max(annual_max$max_discharge)*1.1, length.out=200)
gev_dens <- dgev(xv, loc=loc, scale=scale, shape=shape)
dens_df <- data.frame(x = xv, y = gev_dens)

p_gev <- ggplot(annual_max, aes(x = max_discharge)) +
  geom_histogram(aes(y = after_stat(density)), bins = 20, fill = 'grey80', color = 'black') +
  geom_line(data = dens_df, aes(x = x, y = y), color = 'red', linewidth = 1, inherit.aes = FALSE) +
  labs(title = 'Annual maxima and fitted GEV (discharge)')
print(p_gev)
```


# 4 Peaks-over-threshold (POT) and GPD for precipitation

### Methodology
Select the 95% empirical quantile as threshold and fit a GPD to exceedances (ismev::gpd.fit). Use the empirical exceedance rate to compute approximate T-year return levels.

### Results / Comments
The GPD fit and an example 10-year return level estimate are reported below.

```{r pot-gpd}
threshold95 <- quantile(df$precip, 0.95, na.rm=TRUE)
th <- as.numeric(threshold95)
exceedances <- df$precip[df$precip > th]
excesses <- exceedances - th
cat('Threshold used (95%):', th, 'Number exceedances:', length(excesses), '\n')

gpd_fit <- gpd.fit(df$precip, threshold = th, show = FALSE)
print(gpd_fit)

nu_hat <- gpd_fit$mle[2]
beta_hat <- gpd_fit$mle[1]
p_exceed <- mean(df$precip > th, na.rm=TRUE)
return_level_pot <- function(T_years){
  p_annual <- 1/(T_years*365)
  if(abs(nu_hat) < 1e-6){
    z <- th + beta_hat * log(p_exceed / p_annual)
  } else {
    z <- th + (beta_hat/nu_hat) * ( (p_exceed / p_annual)^{nu_hat} - 1 )
  }
  return(z)
}
cat('Approx 10-year return level (precip):', return_level_pot(10), '\n')
```

  threshold95 <- quantile(df$precip, 0.95, na.rm=TRUE)
# 5 Declustering

### Methodology
Use a simple runs declustering: within runs of consecutive exceedances keep only the maximum value. This reduces temporal dependence of peaks prior to tail modeling.

### Results / Comments
  knitr::kable(gpd_fit, caption = 'GPD fit summary')

```{r decluster}
decluster_runs <- function(dates, series, threshold, run_length_days = 3){
  idx_exceed <- which(series > threshold)
  if(length(idx_exceed)==0) return(integer(0))
  groups <- cumsum(c(1, diff(idx_exceed) > run_length_days))
  keep_idx <- tapply(idx_exceed, groups, function(idxs) idxs[which.max(series[idxs])])
  return(as.integer(unlist(keep_idx)))
}
kept <- decluster_runs(df$date, df$precip, th, run_length_days = 2)
cat('After declustering (run=2 days) kept exceedances:', length(kept), '\n')
```


# 6 Tail dependence and scatter

### Methodology
Compute the empirical conditional probability P(discharge>q_d | precip>q_p) at high quantiles (95%) and display a scatter of top quantiles.

### Results / Comments
This measure gives a quick, empirical look at tail association between high precipitation and high discharge on the same day.

```{r tail-dependence, fig.width=6, fig.height=5}
q_p <- quantile(df$precip, 0.95, na.rm=TRUE)
q_d <- quantile(df$discharge, 0.95, na.rm=TRUE)
cond_prob <- mean(df$discharge > q_d & df$precip > q_p, na.rm=TRUE) / mean(df$precip > q_p, na.rm=TRUE)
cat('Empirical P(discharge>q_d | precip>q_p) at 95% quantiles:', cond_prob, '\n')

top_df <- df %>% filter(precip > q_p | discharge > q_d)
print(ggplot(top_df, aes(x=precip, y=discharge)) + geom_point(alpha=0.6) +
  geom_hline(yintercept = q_d, color='red', linetype='dashed') +
  geom_vline(xintercept = q_p, color='red', linetype='dashed') +
  labs(title='Scatter of precip vs discharge (top quantiles)'))
```


# 7 Extreme causality tests

### Methodology
Source `JuroExtremes.R` and run the provided `Extreme_causality_test` for several future lags in both directions (precip→discharge and discharge→precip). We use bootstrap repetitions for stability.

### Results / Comments
The causality test outputs indicate whether extreme precipitation precedes extreme discharge at the tested lags. Results are printed below.

```{r causality}
helpers_path <- file.path('practical_1','JuroExtremes.R')
if(file.exists(helpers_path)){
  source(helpers_path)
} else stop('JuroExtremes.R not found')

common_idx <- which(!is.na(df$discharge) & !is.na(df$precip))
xseries <- df$precip[common_idx]
yseries <- df$discharge[common_idx]

res_list <- list()
for(lag_f in 0:3){
  res <- Extreme_causality_test(xseries, yseries, z = NULL, lag_future = lag_f, p_value_computation = FALSE, bootstrap_repetitions = 100)
  res_list[[as.character(lag_f)]] <- res
  cat('Lag', lag_f, ':', as.character(res$output), 'CTC=', res$CTC, 'baseline=', res$baseline, '\n')
}

res_rev <- list()
for(lag_f in 0:3){
  res2 <- Extreme_causality_test(yseries, xseries, z = NULL, lag_future = lag_f, p_value_computation = FALSE, bootstrap_repetitions = 100)
  res_rev[[as.character(lag_f)]] <- res2
  cat('Reverse Lag', lag_f, ':', as.character(res2$output), '\n')
}

saveRDS(list(gev_fit=gev_fit, gpd_fit=gpd_fit, causality_precip_to_discharge = res_list, causality_rev = res_rev), file = file.path('practical_1','practical1_results.rds'))
```

# Takeaways

- Discharge annual maxima were modeled with a GEV; model parameters and a 100-year return level are reported above.
- Precipitation extremes (POT) were modeled with a GPD using the 95% quantile as threshold; an approximate 10-year return level is provided.
- Declustering reduces clusters of exceedances; the retained exceedances are used for inference.
- Empirical tail-dependence at 95% shows a small conditional probability that large precip coincides with large discharge in the same day.
- The provided extreme-causality test suggests evidence of causality from precipitation to discharge at some positive lags (see outputs); the reverse direction showed no causality in this analysis.

# Rendering to PDF

This RMarkdown is set to produce a PDF via the `pdflatex` engine. To knit to PDF from R you can run:

```r
rmarkdown::render('practical_1/Practical1_report.Rmd', output_format = 'pdf_document')
```

Note: producing PDF requires a working LaTeX installation (MiKTeX, TeX Live, MacTeX). A convenient lightweight option inside R is to install TinyTeX:

```r
if(!requireNamespace('tinytex', quietly = TRUE)) install.packages('tinytex')
tinytex::install_tinytex()
```

If LaTeX is not available, you can render HTML instead and convert to PDF later (or use the RStudio knit button which often helps resolve path issues):

```r
# Format results into a tidy table for presentation
format_res <- function(res_list, direction_label){
  do.call(rbind, lapply(names(res_list), function(lag){
    r <- res_list[[lag]]
    data.frame(
      lag = as.integer(lag),
      direction = direction_label,
      outcome = as.character(r$output),
      CTC = round(r$CTC, 4),
      baseline = round(r$baseline, 4),
      stringsAsFactors = FALSE
    )
  }))
}
rmarkdown::render('practical_1/Practical1_report.Rmd', output_format = 'html_document')
```

---

Generated on `r Sys.time()`


---

## Appendix A — Full model objects and raw POT data

The full `gpd_fit` object (including `$data`, `$vals` and `$xdata`) and other internal objects are saved in `practical_1/practical1_results.rds`. If you need to inspect the raw output, load the RDS file in R and print the components. Example:

```{r appendix-print, eval = FALSE}
# full <- readRDS('practical_1/practical1_results.rds')
# print(full$gpd_fit)
# str(full$gpd_fit)
```
